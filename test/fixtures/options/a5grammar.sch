;;; Test input generator for assignment 5.
;;;
;;; Based on a fairly general purpose generator of test inputs
;;; from context-free grammars.
;;;
;;; FIXME: uses some Larceny-specific features

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Given a list of strings,
;;; returns the string obtained by appending them together.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (strings->string strings)
  (apply string-append strings))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Pseudo-random number generator.
;;; FIXME: specific to Larceny
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define seed (current-seconds))
(define mult 7531)
(define mask #xFFFF)
(define more 10000)

(define (myrandom n)
  (set! seed
        (bitwise-and mask
                     (+ (random n) more (* mult seed))))
  (mod seed n))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Grammars are represented as lists in the form
;;;
;;; ((S1 P11 P12 ...)
;;;  (S2 P21 P22 ...)
;;;  ...)
;;;
;;; where
;;;
;;; the Si are nonterminals (represented by Scheme symbols)
;;; the Pij are productions (represented by lists)
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; The grammar for assignment 5,
;;; modified to enforce reasonable restrictions on integer parameters.

(define grammar5
  '((<input> (<instrument_spec>
              <time_spec>
              <key_spec>
              <length_spec>))
    (<instrument_spec> ()
                       (<whitespace>
                        "instrument:"
                        <whitespace>
                        <instr>
                        <whitespace>
                        <ls>))
    (<time_spec> ()
                 (<whitespace>
                  "time signature:"
                  <whitespace>
;;;               <int> "/" <int>
                  <num> "/" <den>
                  <whitespace>
                  <ls>))
    (<key_spec> ()
                (<whitespace>
                 "key:"
                 <whitespace>
                 <key>
                 <whitespace>
                 <ls>))
    (<length_spec> ()
                   (<whitespace>
                    "length:"
                    <whitespace>
;;;                 <int>
                    <length>
                    <whitespace>
                    <ls>))
    (<instr> ("soprano recorder")
             ("alto recorder")
             ("concert flute")
             ("oboe")
             ("bassoon")
             ("violin")
             ("cello")
             ("guitar")
             ("piano"))
    (<key> (<pitch>)
           (<pitch> <whitespace> "major")
           (<pitch> <whitespace> "minor"))
    (<pitch> ("Ab") ("A") ("A#") ("Bb") ("B") ("B#")
             ("Cb") ("C") ("C#") ("Db") ("D") ("D#")
             ("Eb") ("E") ("E#") ("Fb") ("F") ("F#")
             ("Gb") ("G") ("G#"))
    (<int> (<digit>) (<digit> <int>))
    (<digit> ("0") ("1") ("2") ("3") ("4") ("5")
             ("6") ("7") ("8") ("9"))
    (<whitespace> () (" " <whitespace>))
    (<ls> ("\n") ("\r") ("\r\n"))

    ;; added

    (<num> ("2") ("3") ("4") ("5") ("6") ("7") ("9"))
    (<den> ("2") ("4") ("8"))
    (<length> ("16") ("32") ("48") ("64")) ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Given a context-free grammar and non-negative integer n,
;;; returns a list of n pseudo-randomly generated strings
;;; in the language generated by the grammar.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (generate-strings grammar n)
  (if (> n 0)
      (cons (generate-string grammar)
            (generate-strings grammar (- n 1)))
      '()))

(define (generate-string grammar)

  ;; Given a list of nonterminals and strings alpha,
  ;; and a list of strings rev such that
  ;;
  ;;     (append (reverse rev) alpha)
  ;;
  ;; can be derived from the grammar's start symbol,
  ;; returns a string in the language generated by the grammar.

  (define (rewrite alpha rev)
    (cond ((null? alpha)
           (strings->string (reverse rev)))
          ((string? (car alpha))
           (rewrite (cdr alpha)
                    (cons (car alpha)
                          rev)))
          ((symbol? (car alpha))
           (let* ((probe (assq (car alpha) grammar))
                  (ignored (assert (pair? probe)))
                  (productions (cdr probe))
                  (production
                   (list-ref productions
                             (myrandom (length productions)))))
             (rewrite (append production (cdr alpha))
                      rev)))
          (else
           (error 'rewrite
                  "defective grammar"
                  (car alpha)))))

  (rewrite (list (car (car grammar))) '()))
